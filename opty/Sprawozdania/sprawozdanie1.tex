%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and 
% move this file to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo}
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage{polski}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[calc]{datetime2}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{placeins}
\usepackage[figurename=Rys.]{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{tikz} % To generate the plot from csv
\usepackage{mathtools}
\usepackage{pgfplots}
\pgfplotsset{
    legend entry/.initial=,
    every axis plot post/.code={%
        \pgfkeysgetvalue{/pgfplots/legend entry}\tempValue
        \ifx\tempValue\empty
            \pgfkeysalso{/pgfplots/forget plot}%
        \else
            \expandafter\addlegendentry\expandafter{\tempValue}%
        \fi
    },
}
\captionsetup[subfigure]{skip=30pt} % global setting for subfigure
\newcommand{\lstlistingnames}{Algorytmie}% Listing -> Algorithm
\renewcommand{\lstlistingname}{Algorytm}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\renewcommand{\lstlistingname}{Algorytm}% Listing -> Algorithm
\newcommand{\wyjT}{gdzie $T$ to oszacowana ilość operacji a $n$ rozmiar tablicy do posortowania.\\}



\pgfplotsset{compat=newest} % Allows to place the legend below plot
\usepgfplotslibrary{units} % Allows to enter the units nicely

\sisetup{
  round-mode          = places,
  round-precision     = 2,
}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE Politechnika Łódzka}\\[1.5cm] % Name of your university/college
\textsc{\Large Szybkie algorytmy}\\[0.5cm] % Major heading such as course name

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Techniki zwiększenie efektywności algorytmów }\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------



\begin{flushleft}\large

\begin{center} \emph{Prowadzący zajęcia:} \end{center}
\begin{center}
prof. dr hab. Mykhaylo \textsc{Yatsymirskyy}
\end{center} % Supervisor's Name
\end{flushleft}


% If you don't want a supervisor, uncomment the two lines below and remove the section above
\Large \emph{Autor:}\\
Filip \textsc{Rynkiewicz}\\[2cm] % Your name


%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[scale=0.36]{logo.png}\\[1.3cm]
 

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[5cm] % Date, change the \today to a set date if you want to be precise

\vfill % Fill the rest of the page with whitespace

\end{titlepage}





\lstset{language=C++,
                 basicstyle=\ttfamily\footnotesize,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#},
				breaklines=true,
    			numbers=left,
    			    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}


\pgfplotsset{
          width=\linewidth, % Scale the plot to \linewidth
          grid=major, 
          grid style={dashed,gray!30},
          xlabel=Ilosc elementow w tablicy, % Set the labels
          ylabel=Czas wykonania [ms] ,
          x tick label style={rotate=0,anchor=east,align=right,yshift=-1.5ex},
          scaled y ticks = false,  
          scaled x ticks = false,   
		  legend pos=north west,
 		  samples=61,
    	  width=5in,
    	  height=3in,
          ymin=0,
          try min ticks =6,
          max space between ticks=15000pt,
          x tick label style=
          {
          /pgf/number format/fixed,
     	 /pgf/number format/1000 sep = \thinspace % Optional if you want to replace comma as the 1000 separator 
      	  },
      	  y tick label style=
          {
          /pgf/number format/fixed,
     	 /pgf/number format/1000 sep = \thinspace % Optional if you want to replace comma as the 1000 separator 
      	  },
      	  xmin=0
}
\section{Informacje o sprzęcie testowym}
Do pomiaru czasu zostały wykorzystane funkcje \textit{QueryPerformanceCounter} oraz \textit{QueryPerformanceFrequency} z biblioteki \textbf{windows.h}. Wszystkie testy zostały wykonane na maszynie z systemem Windows 8.1Pro 64, z procesorem Intel(R) Core(TM) i7-5700HQ CPU @ 2.70GHz. Testy zostały przeprowadzone na kompilatorze \textit{mingw32-c++.exe (GCC) 5.3.0} z flagą \textit{-std=gnu++11} zapewniającą wsparcie \textit{C++11}.
\section{Przyjęte własność}
Jako optymistyczny przypadek została przyjęta sytuacja w której algorytm ma za zadanie posortować już posortowaną tablice.\\
Jako pesymistyczny przypadek przyjmuję się sytuacje w której algorytm ma posortować tablice posortowaną w odwrotnym kierunku niż pożądany.\\
Jako średni przypadek zostało przyjęta sytuacja w której tablica zawiera w sobie elementy losowe.\\
 Każde porównanie algorytmów zostało przeprowadzone na tych samych danych wejściowych. Wszystkie algorytmy, te zmodyfikowane oraz te dla par, zostały napisane przez autora.
\section{Algorytm sortowania przez wstawianie}

\subsection*{Dla dwóch elementów}

Początkowym krokiem algorytmu jest posortowanie  par $(x,y) $ w zbiorze $V  $, gdzie każda para $(x,y) \in V$,  tak aby pierwsza liczba $x$  była zawsze liczba mniejsza od liczby $y$. Indeksy liczby $x$ jest zawsze o jeden mniejszy od indeksu liczby $y$ w zbiorze.\\
 Kolejnym krokiem tego sortowania będzie wybranie  pary $(x',y')$. Pary wybierane są poprzez przesuwanie od indeksu 2 zbioru $V$, ponieważ zakładamy ze pierwsza para jest posortowana, zawsze o 2 indeksy. Każde przejście zaczyna się od elementu $V[i+2]$\footnote{Indeks $i+2$ ze zbioru $V$, gdzie i jest kolejna iteracja algorytmu.}.\\
Po wybraniu pary $(x',y')$ następuje porównywanie elementu $y'$ z elementem $z$, który poprzedza wybrana parę oraz indeks $z \in \lvert V \rvert $. Dopóki  $z > y'$  wykonuje się przesuniecie całej pary przed liczbę $z$. Za każdym razem liczba $z$ jest liczba poprzedzająca liczbę $x'$.
Jeżeli  $z < y'$ algorytm przechodzi do porównania $z > x'$ . Jeżeli zostanie spełniony ten warunek liczba mniejsza z pary zostaje przestawiona przed liczba $z$.
\subsection*{Oszacowanie złożoności}
\subsubsection*{Optymistyczna}
W tym przypadku złożoność obliczeniowa będzie wynosiła $O(n)$.
Wynika to z faktu że :
\begin{itemize}
\item   Pierwsza pętla \textit{for}(4 linijka) zostanie wykonana dokładnie $\frac{n}{2}$ razy.
\item Druga pętla \textit{for}(11 linijka) zostanie wykonana $\frac{n-2}{2}$ razy.
\item Pierwsza zagnieżdżona pętla \textit{while}(16 linijka) zostanie wykonana $0$ razy.
\item Druga zagnieżdżona pętla \textit{while}(23 linijka) zostanie wykonana $0$ razy.
\item Jeżeli tablica jest o rozmiarze nieparzystym dodatkowo zostanie wykonane$ 0$ iteracji(34 linijka).
\end{itemize}
\begin{equation}
T \approx \frac{n}{2} + \frac{n-2}{2} = n-1
\end{equation}
\wyjT
Zerowa ilość przejść w przypadku wszystkich pętli \textit{while} wynika z faktu że zawarte w nich instrukcje zawsze będą warunkiem kończącym pętlę, zatem nigdy nie zostaną wykonane.

\subsubsection*{Pesymistyczna}
Złożoność obliczeniowa będzie wynosiła $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla \textit{for}(4 linijka) zostanie wykonana dokładnie $\frac{n}{2}$ razy.
\item Druga pętla \textit{for}(11 linijka) zostanie wykonana dokładnie $\frac{n-2}{2}$ razy.
\item Pierwsza zagnieżdżona pętla \textit{while}(16 linijka) zostanie wykonana $\approx \frac{n}{2}$ razy.
\item Druga zagnieżdżona pętla \textit{while}(23 linijka) zostanie wykonana $\approx \frac{n}{2}$ razy.
\item Jeżeli tablica jest o rozmiarze nieparzystym dodatkowo zostanie wykonane $n-2$ iteracji(34 linijka).
\end{itemize}
\begin{equation*}
T \approx \frac{n}{2} + \frac{n-2}{2}\cdot(n)+ (n-2)= \frac{n^2}{2} + \frac{n}{2} -2
\end{equation*}
\wyjT

Ponieważ obie pętle \textit{while} korzystają z tego samego iteratora, zostało przyjęte że obie w sumie wykonają się $n$ razy, więc średnio każda wykona się $\frac{n}{2}$.
\subsubsection*{Średnia}
Złożoność obliczeniowa będzie wynosiła $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla \textit{for}(4 linijka) zostanie wykonana dokładnie $\frac{n}{2}$ razy.
\item Druga pętla \textit{for}(11 linijka) zostanie wykonana dokładnie $\frac{n-2}{2}$ razy.
\item Pierwsza zagnieżdżona pętla \textit{while}(16 linijka) zostanie wykonana $\approx \frac{2}{n}$ razy.
\item Druga zagnieżdżona pętla \textit{while}(23 linijka) zostanie wykonana $\approx \frac{2}{n}$ razy.
\item Jeżeli tablica jest o rozmiarze nieparzystym dodatkowo zostanie wykonane $n-2$ iteracji(34 linijka).
\end{itemize}
\begin{equation*}
\begin{multlined}
T \approx \frac{n}{2} + \frac{n-2}{2}\cdot(n)+ (n-2)= \frac{n^2}{2} + \frac{n}{2} -2
\end{multlined}
\end{equation*}

\wyjT
\subsubsection*{Kod}
\begin{lstlisting}[label{lst:wstawianie}]
void sort(std::vector<int> &toSort)
{
 const int sizeOfArray=toSort.size()-(toSort.size()%2);
 for(int i=0; i<sizeOfArray; i+=2)
  {
   if(toSort[i] > toSort[i+1])
    {
     std::swap(toSort[i],toSort[i+1]);
    }
  }
 for(int i=2; i<sizeOfArray; i+=2)
  {
   const int pom1 = toSort[i];
   const int pom2 = toSort[i+1];
   int j = i-1;
   while(j>=0 && toSort[j]>pom2)
    {
     toSort[j+2] =  toSort[j];
     j--;
    }
   toSort[j+2] = pom2;
   toSort[j+1] = pom1;
   while(j>=0 && toSort[j]>pom1)
    {
     toSort[j+1] = toSort[j];
     --j;
    }
   toSort[j+1] = pom1;
 }
 if(toSort.size()%2==1)
  {
   const int pom = toSort[toSort.size()-1];
   int k = toSort.size()-2;
   while(k>=0 && toSort[k]>pom)
    {
     toSort[k+1] = toSort[k];
     --k;
    }
   toSort[k+1] = pom;
  }
}
\end{lstlisting}

\subsubsection*{Wyniki}
\par Rys.~\ref{fig:insertRand} przedstawia wyniki dla tablicy z losowymi elementami. Na wykresie można zauważyć przyspieszenie względem standardowego algorytmu. Przyspieszenie to wynosi $ \approx 34 \% $.Opisana wcześniej złożoność dla tego przypadku jest taka sama jak dla standardowej implementacji. Jednakże fakt że algorytm bierze pod uwagę parę i najpierw sortuje po największym elemencie a potem po najmniejszym zmniejsza znacząco ilość porównań. Doprowadza to do tego że teoretyczne i maksymalne przyspieszenie powinno wynieść $ \approx 50\% $ przy tym pomyśle, uwzględniając idealną implementację.
\par Rys.~\ref{fig:Insertbest} przedstawia wyniki dla tablicy która została już posortowana. Jak można zauważyć implementacja standardowa jest szybsza niż zaimplementowana tutaj. Jednakże różnica w czasie działania obu funkcji wynosi około $0.1ms$, wiec można uznać że są takie same. Ponieważ jedyną akcją która jest zależna od rozmiaru tablicy jest pętla przestawiająca pary oraz pętla przeszukująca tablice co dwa elementy złożoność obliczeniowa będzie liniowa $O(n)$.
\par Rys.~\ref{fig:InsertWorst} przedstawia wyniki dla pesymistycznego ułożenia tablicy. W tym wypadku implementacja algorytmu dla par działa o $\approx 50 \% $ szybciej od standardowej implementacji. Wynika to z faktu że, tak samo jak w średnim przypadku, iteracja pętla odpowiedzialna za przestawianie par wynosi $\frac{n-2}{2}$ przez co faktycznie algorytm przyspiesza do $\approx 150 \% $ szybkości algorytmu podstawowego.
%\caption{Wyniki dla sortowania przez wstawianie}\label{fig:insert}
\begin{figure}[!h]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortInsertTupleTest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortInsertTupleTest.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy ze elementami losowymi}\label{fig:insertRand}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[!h]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortInsertTupleTestBest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortInsertTupleTestBest.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najlepszym rozkładem elementów}\label{fig:Insertbest}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[!h]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortInsertTupleTestWorst.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortInsertTupleTestWorst.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najgorszym rozkładem elementów}\label{fig:InsertWorst}
  \end{center}
  \end{figure}\FloatBarrier

%\end{figure}
\FloatBarrier

\section{Algorytm sortowania bąbelkowego}
\subsection*{Dla dwóch elementów}
Podstawowa wersja tego algorytmu polega na porównywaniu ze sobą dwóch kolejnych elementów $(x,y) \in V$ i zmianie ich kolejności, mając tylko jeden bąbelek który wypływa na początek lub na koniec zbioru. \\
Zakładając ze mamy porównywać dwie liczby, zostało przyjęte ze są dwa bąbelki. Jeden który idzie na początek zbioru  $V$ oraz drugi który idzie na koniec zbioru $V$. \\
Dla każdej pary $(x',y') \in V$ składającej się z kolejnych elementów ze zbioru $V$:
\begin{itemize} 
\item Posortuj parę $(x',y)'$ rosnąco
\item Dla każdej liczby $z$ poprzedzającej $x'$ zamień ze sobą te elementy jeżeli \begin{equation*}x' < z\end{equation*} 
\item  Dla każdej liczby $w$ nastepujacej $y'$ zamień ze sobą te elementy jeżeli  \begin{equation*}y'>w\end{equation*}
 \end{itemize}  

\subsubsection*{Kod}

\begin{lstlisting}[caption={Sortowanie babelkowe dla par},label={lst:babelek}]
void sort(std::vector<int> &toSort)
{
 for(int i= 0; i<(toSort.size()-1); i++)
 {
  int minElem=i,maxElem=i+1;
  if(toSort[minElem]>toSort[maxElem])
   {
    std::swap(toSort[minElem],toSort[maxElem]);
   }
  while(minElem>0 && toSort[minElem]<toSort[minElem-1])
   {
    std::swap(toSort[minElem],toSort[minElem-1]);
    minElem--;
   }
  while(maxElem<(toSort.size()-1) && toSort[maxElem]>toSort[maxElem+1])
   {
    std::swap(toSort[maxElem],toSort[maxElem+1]);
    maxElem++;
   } 
 }
}
\end{lstlisting}
 \subsection*{Oszacowanie złożoności}

\subsubsection*{Optymistyczna}
Najlepszy przypadek tego algorytmu ma złożoność obliczeniową $O(n)$. 
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-1$
\end{itemize}

\begin{equation*}
T \approx n -1
\end{equation*}
\wyjT
\subsubsection*{Pesymistyczna}
Najgorszy przypadek algorytmu sortowania bąbelkowego dla par ma złożoność obliczeniową $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-1$
\item Pętla \textit{while}(10 linijka)  w najgorszym przypadku wykona się $n$ razy
\item Pętla \textit{while}(15 linijka)  w najgorszym przypadku wykona się $n$ razy
\end{itemize}
\begin{equation*}
T \approx (n -1) \cdot (2n) 
\end{equation*}
\wyjT
\subsubsection*{Średnia}
Dla losowych elementów w tablicy sortowanie to ma złożoność obliczeniową $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-1$
\item Pętla \textit{while}(10 linijka)  w tym przypadku wykona się $\frac{2}{n}$ razy
\item Pętla \textit{while}(15 linijka)  w tym przypadku wykona się $\frac{2}{n}$ razy
\end{itemize}
\begin{equation*}
T \approx n -1\cdot (2 \cdot \frac{2}{n}) = (n-1) \cdot (2n) 
\end{equation*}
\wyjT
\subsubsection*{Wyniki}
\par Rys.~\ref{fig:bubbleRand} przedstawia efekt porównania działania obu algorytmów dla tablic z losowymi elementami. Z przedstawionego wykresu wyraźnie widać przyspieszenie. Maksymalne przyspieszenie dla tego algorytmu wynosi $\approx 70\%$. Dzięki zastosowaniu wewnętrznych pętli \textit{while} które sterują zachowaniem bąbelków można bardzo szybko przyspieszyć algorytm. Dzięki temu że średnio każda pętla wykonuję się połowę rozmiaru tablicy. Wiec teoretyczne przyspieszenie powinno być co najmniej $50 \% $.	
\par Rys.~\ref{fig:bubbleBest} reprezentuje graficznie otrzymane wyniki z porównania algorytmu sortowania bąbelkowego dla par i normalnego dla posortowanej tablicy. Ponieważ widoczna na wykresie czerwona linia, reprezentująca sortowanie dla par, jest zawsze bliska zeru, mozna wyciągnać wniosek. Sortowanie to ma złożoność obliczeniową $O(n)$. Wiec przyspieszenie wynosi $\approx 99\%$
\par Rys.~\ref{fig:bubbleWorst} przedstawia wyniki dla tablicy posortowanej w druga stronę. Przyspieszenie algorytmu wynosi w tym wypadku $\approx 50\%$. Ponieważ używamy dwóch bąbelków, w porównaniu do użycia jednego , zmniejsza czas wykonania o $50\%$.


\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortBubbleTupleTest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortBubbleTupleTest.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy ze elementami losowymi}\label{fig:bubbleRand}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortBubbleTupleTestBest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortBubbleTupleTestBest.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najlepszym rozkładem elementów}\label{fig:bubbleBest}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortBubbleTupleTestWorst.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortBubbleTupleTestWorst.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najgorszym rozkładem elementów}\label{fig:bubbleWorst}
  \end{center}
\end{figure}
\FloatBarrier

\section{Algorytm sortowania przez wybieranie}
\subsection*{Dla dwóch elementów}
Podstawowa wersja algorytmu zakłada wybieranie najmniejszej lub największej wartośći z zbioru. Ten pomysł wybiera największą oraz najmniejszą wartość.
\subsubsection*{Kod}
\begin{lstlisting}
void sort(std::vector<int> &toSort)
{
 int vectorSize=0;
 if(toSort.size()%2!=0)
  {
   vectorSize++;
   std::iter_swap((std::min_element(toSort.begin(),toSort.end())),toSort.begin());
  }
 std::vector<int>::iterator _begin = toSort.begin()+vectorSize;
 std::vector<int>::iterator _end = toSort.end() - 1;
 while (_begin < _end)
  {
   std::vector<int>::iterator it=_begin,_min=it,_max=it;
   for (it = _begin; it <= _end; ++it)
    {
     if ((*it) < (*_min))
      {
       _min = it;
      }
     else if ((*it) > (*_max))
      {
       _max = it;
      }
    }
 std::iter_swap(_min,_begin);
 if(_begin==_max)
  {
   _max=_min;
  }
 std::iter_swap(_max,_end);
 ++_begin;
 --_end;
  }
}
\end{lstlisting}
\subsubsection*{Wyniki}
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortSelectionTupleTest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortSelectionTupleTest.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy ze elementami losowymi}
  \end{center}
  \end{figure}
  \begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortSelectionTupleTestBest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortSelectionTupleTestBest.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najlepszym rozkładem elementów}
  \end{center}
  \end{figure}
  \begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortSelectionTupleTestWorst.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortSelectionTupleTestWorst.csv};
       
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najgorszym rozkładem elementów}
  \end{center}
  \end{figure}
\FloatBarrier


\end{document}
