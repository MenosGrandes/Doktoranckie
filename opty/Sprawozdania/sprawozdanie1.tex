%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and 
% move this file to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo}
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage{polski}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[calc]{datetime2}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{placeins}
\usepackage[figurename=Rys.]{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{tikz} % To generate the plot from csv
\usepackage{mathtools}
\usepackage{titlesec}
\usepackage{pgfplots}
\pgfplotsset{
    legend entry/.initial=,
    every axis plot post/.code={%
        \pgfkeysgetvalue{/pgfplots/legend entry}\tempValue
        \ifx\tempValue\empty
            \pgfkeysalso{/pgfplots/forget plot}%
        \else
            \expandafter\addlegendentry\expandafter{\tempValue}%
        \fi
    },
}
\captionsetup[subfigure]{skip=30pt} % global setting for subfigure
\newcommand{\lstlistingnames}{Algorytmie}% Listing -> Algorithm
\renewcommand{\lstlistingname}{Algorytm}% Listing -> Algorithm
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}
\renewcommand{\lstlistingname}{Algorytm}% Listing -> Algorithm
\newcommand{\wyjT}{gdzie $T$ to oszacowana ilość operacji a $n$ rozmiar tablicy do posortowania.\\}



\pgfplotsset{compat=newest} % Allows to place the legend below plot
\usepgfplotslibrary{units} % Allows to enter the units nicely

\sisetup{
  round-mode          = places,
  round-precision     = 2,
}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\addto\captionsenglish{% Replace "english" with the language you use
  \renewcommand{\contentsname}%
    {Spis treści}%
}


\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE Politechnika Łódzka}\\[1.5cm] % Name of your university/college
\textsc{\Large Szybkie algorytmy}\\[0.5cm] % Major heading such as course name

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Techniki zwiększenie efektywności algorytmów }\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------



\begin{flushleft}\large

\begin{center} \emph{Prowadzący zajęcia:} \end{center}
\begin{center}
prof. dr hab. Mykhaylo \textsc{Yatsymirskyy}
\end{center} % Supervisor's Name
\end{flushleft}


% If you don't want a supervisor, uncomment the two lines below and remove the section above
\Large \emph{Autor:}\\
Filip \textsc{Rynkiewicz}\\[2cm] % Your name


%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[scale=0.36]{logo.png}\\[1.3cm]
 

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[5cm] % Date, change the \today to a set date if you want to be precise

\vfill % Fill the rest of the page with whitespace

\end{titlepage}





\lstset{language=C++,
                 basicstyle=\ttfamily\footnotesize,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#},
				breaklines=true,
    			numbers=left,
    			    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}


\pgfplotsset{
          width=\linewidth, % Scale the plot to \linewidth
          grid=major, 
          grid style={dashed,gray!30},
          xlabel=Ilość elementów w tablicy, % Set the labels
          ylabel=Czas wykonania [ms] ,
          x tick label style={rotate=0,anchor=east,align=right,yshift=-1.5ex},
          scaled y ticks = false,  
          scaled x ticks = false,   
		  legend pos=north west,
 		  samples=61,
    	  width=5in,
    	  height=3in,
          ymin=0,
          try min ticks =6,
          max space between ticks=15000pt,
          x tick label style=
          {
          /pgf/number format/fixed,
     	 /pgf/number format/1000 sep = \thinspace % Optional if you want to replace comma as the 1000 separator 
      	  },
      	  y tick label style=
          {
          /pgf/number format/fixed,
     	 /pgf/number format/1000 sep = \thinspace % Optional if you want to replace comma as the 1000 separator 
      	  },
      	  xmin=0
}

 \tableofcontents 
 
\section{Informacje o sprzęcie testowym}
Do pomiaru czasu zostały wykorzystane funkcje \textit{QueryPerformanceCounter} oraz \textit{QueryPerformanceFrequency} z biblioteki \textbf{windows.h}. Wszystkie testy zostały wykonane na maszynie z systemem Windows 8.1Pro 64, z procesorem Intel(R) Core(TM) i7-5700HQ CPU @ 2.70GHz. Testy zostały przeprowadzone na kompilatorze \textit{mingw32-c++.exe (GCC) 5.3.0} z flagą \textit{-std=gnu++11} zapewniającą wsparcie \textit{C++11}.
\section{Przyjęte własność}
Jako optymistyczny przypadek została przyjęta sytuacja w której algorytm ma za zadanie posortować już posortowaną tablice.\\
Jako pesymistyczny przypadek przyjmuję się sytuacje w której algorytm ma posortować tablice posortowaną w odwrotnym kierunku niż pożądany.\\
Jako średni przypadek zostało przyjęta sytuacja w której tablica zawiera w sobie elementy losowe.\\
 Każde porównanie algorytmów zostało przeprowadzone na tych samych danych wejściowych. Wszystkie algorytmy, te zmodyfikowane oraz te dla par, zostały napisane przez autora.
\section{Algorytm sortowania przez wstawianie}

\subsection{Dla dwóch elementów}
 Każde iteracja zaczyna się od elementu $V[i+2]$\footnote{Indeks $i+2$ ze zbioru $V$, gdzie $i$ jest kolejna iteracja algorytmu.}.\\
Pierwszym krokiem tego sortowania będzie wybranie  pary $(x',y')$. Po wybraniu pary $(x',y')$ , jest ona wstępnie sortowana rosnąco, potem następuje porównywanie elementu $y'$ z elementem $z$, który poprzedza wybrana parę oraz indeks $z \in \lvert V \rvert $. Dopóki  $z > y'$  wykonuje się przesuniecie całej pary przed liczbę $z$. Za każdym razem liczba $z$ jest liczba poprzedzająca liczbę $x'$.Jeżeli  $z < y'$ algorytm przechodzi do porównania $z > x'$ . Jeżeli zostanie spełniony ten warunek liczba mniejsza z pary zostaje przestawiona przed liczba $z$.
\subsubsection{Oszacowanie złożoności}
\paragraph{Optymistyczna}\mbox{}\\
W tym przypadku złożoność obliczeniowa będzie wynosiła $O(n)$.
Wynika to z faktu że :
\begin{itemize}
\item Pierwsza pętla \textit{for}(4 linijka) zostanie wykonana dokładnie $\frac{n}{2}$ razy.
\item Porównanie elementów w parze(6 linijka), i posortowanie jej zawsze zajmie $1$ porównanie.
\item Pierwsza zagnieżdżona pętla \textit{while}(13 linijka) zostanie wykonana $0$ razy.
\item Druga zagnieżdżona pętla \textit{while}(20 linijka) zostanie wykonana $0$ razy.
\item Jeżeli tablica jest o rozmiarze nieparzystym dodatkowo zostanie wykonane $0$ iteracji(31 linijka).
\end{itemize}
\begin{equation}
T \approx \frac{n}{2} 
\end{equation}
\wyjT \\
Zerowa ilość przejść w przypadku wszystkich pętli \textit{while} wynika z faktu że zawarte w nich instrukcje zawsze będą warunkiem kończącym pętlę, zatem nigdy nie zostaną wykonane.

\paragraph{Pesymistyczna}\mbox{}\\
Złożoność obliczeniowa będzie wynosiła $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla \textit{for}(4 linijka) zostanie wykonana dokładnie $\frac{n}{2}$ razy.
\item Porównanie elementów w parze(6 linijka), i posortowanie jej zawsze zajmie $1$ porównania.
\item Pierwsza zagnieżdżona pętla \textit{while}(13 linijka) zostanie wykonana $\frac{n}{2}$ razy.
\item Jeżeli tablica jest o rozmiarze nieparzystym dodatkowo zostanie wykonane $n$ iteracji(31 linijka).
\end{itemize}
\begin{equation*}
T \approx \frac{n^2}{4} + \frac{3n}{2} 
\end{equation*}
\wyjT\\
Ponieważ obie pętle \textit{while} korzystają z tego samego iteratora zawsze zostanie wywołana tylko pierwsza pętla, w tym przypadku.
\paragraph{Średnia}\mbox{}\\
Złożoność obliczeniowa będzie wynosiła $O(n^2)$.

\begin{itemize}
\item Pierwsza pętla \textit{for}(4 linijka) zostanie wykonana dokładnie $\frac{n}{2}$ razy.
\item Porównanie elementów w parze(6 linijka), i posortowanie jej zawsze zajmie $1$ porównania.
\item Pierwsza oraz druga  pętla \textit{while}(13 i 20 linijka) zostaną wykonane łącznie $\approx \frac{n-1}{2}$ razy, ponieważ zależne są od tego samego iteratora.
\item Jeżeli tablica jest o rozmiarze nieparzystym dodatkowo zostanie wykonane $n$ iteracji(31 linijka).
\end{itemize}
\begin{equation*}
\begin{multlined}
T \approx \frac{n}{2} (1+ \frac{n-1}{2})+ n
\end{multlined}
\end{equation*}

\wyjT
\subsubsection{Kod}
\begin{lstlisting}[caption={Sortowanie przez wstawianie dla par},label={lst:wstawianie}]
void sort(std::vector<int> &toSort)
{
 const int sizeOfArray=toSort.size()-(toSort.size()%2);
 for(int i=0; i<sizeOfArray; i+=2)
  {
    if(toSort[i] > toSort[i+1])
     {
      std::swap(toSort[i],toSort[i+1]);
     }
   const int pom1 = toSort[i];
   const int pom2 = toSort[i+1];
   int j = i-1;
   while(j>=0 && toSort[j]>pom2)
    {
     toSort[j+2] =  toSort[j];
     j--;
    }
   toSort[j+2] = pom2;
   toSort[j+1] = pom1;
   while(j>=0 && toSort[j]>pom1)
    {
     toSort[j+1] = toSort[j];
     --j;
    }
   toSort[j+1] = pom1;
 }
 if(toSort.size()%2==1)
  {
   const int pom = toSort[toSort.size()-1];
   int k = toSort.size()-2;
   while(k>=0 && toSort[k]>pom)
    {
     toSort[k+1] = toSort[k];
     --k;
    }
   toSort[k+1] = pom;
  }
}
\end{lstlisting}

\subsection{Dla trzech elementów}
 Każde iteracja zaczyna się od elementu $V[i+3]$\footnote{Indeks $i+3$ ze zbioru $V$, gdzie $i$ jest kolejna iteracja algorytmu.}.\\
Pierwszym krokiem tego sortowania będzie wybranie  trojek $(x',y',z)$. Po wybraniu trojki, jest ona wstępnie sortowana rosnąco.
Wybierz liczbę $w$ która zawsze jest elementem poprzedzającym najmniejszy element z trojki $(x',y',z')$. Następnie zostaną wykonane następujące akcje :
\begin{itemize}
\item Dopóki $w > z'$ przesuń cala trojkę przed $w$, wybierz nowe $w$. Jeżeli warunek zostanie niespełniony przejdź do następnego kroku.
\item Dopóki $w > y'$ przesuń parę $(x',y')$ przed  $w$, wybierz nowe $w$. Jeżeli warunek zostanie niespełniony przejdź do następnego kroku.
\item Dopóki $w > x'$ przesuń $x'$ przed $w$, wybierz nowe $w$. Jeżeli warunek zostanie niespełniony przejedz do kolejnej iteracji.
\end{itemize}

\subsubsection{Oszacowanie złożoności}
\paragraph{Optymistyczna}\mbox{}\\

Złożoność obliczeniowa będzie wynosiła $O(n)$.

\begin{itemize}
\item Jeżeli tablica będzie o rozmiarze nieparzystym to dodatkowo pętla \textit{for}(6 linijka) wykona się $n\%3$ razy.
\item Pierwszy \textit{for} zostanie wykonany $\frac{n-(n\%3)}{3} $ razy.
\end{itemize}
\begin{equation*}
T \approx n\%3+\frac{n-(n\%3)}{3}
\end{equation*}
\wyjT\\
\paragraph{Pesymistyczna}\mbox{}\\
Złożoność obliczeniowa będzie wynosiła $O(n^2)$.

\begin{itemize}

\item Jeżeli tablica będzie o rozmiarze nieparzystym to dodatkowo pętla \textit{for}(6 linijka) wykona się $n\%3$ razy.
\item Pierwszy \textit{for} zostanie wykonany $\frac{n-n\%3}{3}$ razy.
\item Instrukcja warunkowa \textit{else}(27 linijka) zostanie wykonana \textit{1} raz.
\item Pętla \textit{while}(linijka 46) zostanie wykonana $\frac{n-n\%3}{3} +1$  razy.
\end{itemize}
\begin{equation*}
T \approx n\%3 + \frac{n-(n\%3)}{3} \cdot(\frac{n-n\%3}{3} +1)
\end{equation*}
\wyjT\\


\paragraph{Średnia}\mbox{}\\
Złożoność obliczeniowa będzie wynosiła $O(n^2)$.
\begin{itemize}

\item Jeżeli tablica będzie o rozmiarze nieparzystym to dodatkowo pętla \textit{for}(6 linijka) wykona się $n\%3$ razy.
\item Pierwszy \textit{for} zostanie wykonany $\frac{n-n\%3}{3}$ razy.
\item Średnio wszystkie instrukcje wykonają się $3$ razy
\item Wszystkie pętle \textit{while} wykonają się $\frac{n-n\%3}{3}$ razy, ponieważ operują na tym samym iteratorze.
\end{itemize}
\begin{equation*}
T \approx n\%3 + \frac{n-(n\%3)}{3} \cdot(\frac{n-n\%3}{3} +1)
\end{equation*}
\wyjT\\
\subsubsection{Kod}
\begin{lstlisting}[caption={Sortowanie przez wstawianie dla trójek},label={lst:wstawianie}]
void sort(std::vector<int>&toSort)
{
 const int arrayDivider = (toSort.size()%3);
 if(toSort.size()%3!=0)
 {
  for(int i=1; i<arrayDivider; i++)
  {
   const int pom = toSort[i];
   int j = i-1;
   while(j>=0 && toSort[j]>pom)
   {
    toSort[j+1] = toSort[j];
    --j;
   }
   toSort[j+1] = pom;
  }
 }
 for(int i=arrayDivider; i<toSort.size(); i+=3)
 {
  if(toSort[i] < toSort[i+1])
  {
   if(toSort[i+2]<toSort[i])
   {
    std::swap(toSort[i],toSort[i+2]);
   }
  }
  else
  {
   if(toSort[i+1]<toSort[i+2])
   {
    std::swap(toSort[i],toSort[i+1]);
   }
   else
   {
    std::swap(toSort[i],toSort[i+2]);
   }
  }
  if(toSort[i+2]<toSort[i+1])
  {
   std::swap(toSort[i+1],toSort[i+2]);
  }
  const int pom1 = toSort[i];
  const int pom2 = toSort[i+1];
  const int pom3 = toSort[i+2];
  int j = i-1;
  while(j>=0 && toSort[j]>pom3)
  {
   toSort[j+3] =  toSort[j];
   j--;
  }
  toSort[j+3] = pom3;
  toSort[j+2] = pom2;
  toSort[j+1] = pom1;
  while(j>=0 && toSort[j]>pom2)
  {
   toSort[j+2] =  toSort[j];
   j--;
  }
  toSort[j+2] = pom2;
  toSort[j+1] = pom1;
  while(j>=0 && toSort[j]>pom1)
  {
   toSort[j+1] = toSort[j];
   --j;
  }
  toSort[j+1] = pom1;
 }
};
\end{lstlisting}

\subsection{Wyniki}

\par Rys.~\ref{fig:insertRand} przedstawia wyniki dla tablicy z losowymi elementami. Na wykresie można zauważyć przyspieszenie względem standardowego algorytmu. Przyspieszenie to wynosi $ \approx 34 \% $.Opisana wcześniej złożoność dla tego przypadku jest taka sama jak dla standardowej implementacji. Jednakże fakt że algorytm bierze pod uwagę parę i najpierw sortuje po największym elemencie a potem po najmniejszym zmniejsza znacząco ilość porównań. Doprowadza to do tego że teoretyczne i maksymalne przyspieszenie powinno wynieść $ \approx 50\% $ przy tym pomyśle, uwzględniając idealną implementację.
\par Rys.~\ref{fig:Insertbest} przedstawia wyniki dla tablicy która została już posortowana. Jak można zauważyć implementacja standardowa jest szybsza niż zaimplementowana tutaj. Jednakże różnica w czasie działania obu funkcji wynosi około $0.1ms$, wiec można uznać że są takie same. Ponieważ jedyną akcją która jest zależna od rozmiaru tablicy jest pętla przestawiająca pary oraz pętla przeszukująca tablice co dwa elementy złożoność obliczeniowa będzie liniowa $O(n)$.
\par Rys.~\ref{fig:InsertWorst} przedstawia wyniki dla pesymistycznego ułożenia tablicy. W tym wypadku implementacja algorytmu dla par działa o $\approx 50 \% $ szybciej od standardowej implementacji. Wynika to z faktu że, tak samo jak w średnim przypadku, iteracja pętla odpowiedzialna za przestawianie par wynosi $\frac{n-2}{2}$ przez co faktycznie algorytm przyspiesza do $\approx 150 \% $ szybkości algorytmu podstawowego.
%\caption{Wyniki dla sortowania przez wstawianie}\label{fig:insert}
\begin{figure}[!h]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortInsertTupleTest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortInsertTupleTest.csv};
       
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortInsertTupleTest.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy ze elementami losowymi}\label{fig:insertRand}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[!h]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortInsertTupleTestBest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortInsertTupleTestBest.csv};
        
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortInsertTupleTestBest.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najlepszym rozkładem elementów}\label{fig:Insertbest}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[!h]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortInsertTupleTestWorst.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortInsertTupleTestWorst.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortInsertTupleTestWorst.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najgorszym rozkładem elementów}\label{fig:InsertWorst}
  \end{center}
  \end{figure}\FloatBarrier

%\end{figure}
\FloatBarrier

\section{Algorytm sortowania bąbelkowego}
\subsection{Dla dwóch elementów}
Podstawowa wersja tego algorytmu polega na porównywaniu ze sobą dwóch kolejnych elementów $(x,y) \in V$ i zmianie ich kolejności, mając tylko jeden bąbelek który wypływa na początek lub na koniec zbioru. \\
Zakładając ze mamy porównywać dwie liczby, zostało przyjęte ze są dwa bąbelki. Jeden który idzie na początek zbioru  $V$ oraz drugi który idzie na koniec zbioru $V$. \\
Dla każdej pary $(x',y') \in V$ składającej się z kolejnych elementów ze zbioru $V$:
\begin{itemize} 
\item Posortuj parę $(x',y)'$ rosnąco
\item Dla każdej liczby $z$ poprzedzającej $x'$ zamień ze sobą te elementy jeżeli \begin{equation*}x' < z\end{equation*} 
\item  Dla każdej liczby $w$ nastepujacej $y'$ zamień ze sobą te elementy jeżeli  \begin{equation*}y'>w\end{equation*}
 \end{itemize}  


 \subsection{Oszacowanie złożoności}

\paragraph{Optymistyczna}\mbox{}\\
Najlepszy przypadek tego algorytmu ma złożoność obliczeniową $O(n)$. 
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-1$
\end{itemize}

\begin{equation*}
T \approx n -1
\end{equation*}
\wyjT
\paragraph{Pesymistyczna}\mbox{}\\
Najgorszy przypadek algorytmu sortowania bąbelkowego dla par ma złożoność obliczeniową $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-1$
\item Pętla \textit{while}(10 linijka)  w najgorszym przypadku wykona się $n$ razy
\item Pętla \textit{while}(15 linijka)  w najgorszym przypadku wykona się $n$ razy
\end{itemize}
\begin{equation*}
T \approx (n -1) \cdot (2n) 
\end{equation*}
\wyjT
\paragraph{Średnia}\mbox{}\\
Dla losowych elementów w tablicy sortowanie to ma złożoność obliczeniową $O(n^2)$.
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-1$
\item Pętla \textit{while}(10 linijka)  w tym przypadku wykona się $\frac{2}{n}$ razy
\item Pętla \textit{while}(15 linijka)  w tym przypadku wykona się $\frac{2}{n}$ razy
\end{itemize}
\begin{equation*}
T \approx (n -1)\cdot (  \frac{2}{n} + \frac{2}{n}) = (n-1)n
\end{equation*}
\wyjT


\subsubsection{Kod}

\begin{lstlisting}[caption={Sortowanie bąbelkowe dla par},label={lst:babelek}]
void sort(std::vector<int> &toSort)
{
 for(int i= 0; i<(toSort.size()-1); i++)
 {
  int minElem=i,maxElem=i+1;
  if(toSort[minElem]>toSort[maxElem])
   {
    std::swap(toSort[minElem],toSort[maxElem]);
   }
  while(minElem>0 && toSort[minElem]<toSort[minElem-1])
   {
    std::swap(toSort[minElem],toSort[minElem-1]);
    minElem--;
   }
  while(maxElem<(toSort.size()-1) && toSort[maxElem]>toSort[maxElem+1])
   {
    std::swap(toSort[maxElem],toSort[maxElem+1]);
    maxElem++;
   } 
 }
}
\end{lstlisting}
\subsection{Dla trzech elementów}
Pierwszym krokiem tego algorytmu jest pobranie trzech sąsiednich elementów $(x,y,z) \in V$ i posortowanie ich w kolejności rosnącej tworząc trojkę $(x',y',z')$. Liczba $w$ jest zawsze liczba poprzedzająca liczbę $x'$, a liczba $g$ jest liczba poprzedzająca $z'$.
\begin{itemize}
\item Dopóki $y'<w$ przed liczbę $w$ wstaw parę $(x',y')$
\item Dopóki $x'<w$ przed liczbę $w$ wstaw $x'$
\item Dopóki $z'>g$ przed liczbę $g$ wstaw $z'$
\end{itemize}
\subsubsection{Oszacowanie złożoności}
\paragraph{Optymistyczna}\mbox{}\\
Najlepszy przypadek tego algorytmu ma złożoność obliczeniową $O(n)$. 
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-2$
\end{itemize}

\begin{equation*}
T \approx n - 2
\end{equation*}
\wyjT
\paragraph{Pesymistyczna}\mbox{}\\
Najlepszy przypadek tego algorytmu ma złożoność obliczeniową $O(n^2)$. 
\begin{itemize}
\item Pierwsza pętla(3 linijka) \textit{for} jest zależna od rozmiaru tablicy i zostanie wykonana dokładnie $n-2$
\item Jeżeli rozmiar tablicy jest liczbą parzystą to :
\begin{itemize}
\item Pierwsza pętla \textit{while}(28 linijka) wykona się $\frac{(\frac{n}{2}-1)^2+(\frac{n}{2}-1)}{2}$ razy
\item Druga pętla \textit{while}(35 linijka) wykona się $\frac{n}{2}$ razy
\item Trzecia pętla \textit{while}(40 linijka) wykona się $(\frac{n}{2})^2$ razy

\end{itemize}
\item Jeżeli rozmiar tablicy jest liczbą nieparzystą to :
\begin{itemize}
\item Pierwsza pętla \textit{while}(28 linijka) wykona się  $\approx (\frac{n}{2})^{2}$, z zaokrągleniem w dół
\item Druga pętla \textit{while}(35	 linijka) wykona się $0$ razy
\item Trzecia pętla \textit{while}(40 linijka) wykona się $(\frac{n}{2})^2$ razy, z zaokrągleniem w dół

\end{itemize}
\end{itemize}

\paragraph{Średnia}\mbox{}\\
\subsubsection{Kod}
\begin{lstlisting}[caption={Sortowanie bąbelkowe dla trzech elementow},label={lst:babelek}]
void sort(std::vector<int>&toSort)
{
 for(int i= 0; i<toSort.size()-2; i++)
 {
  if(toSort[i] < toSort[i+1])
   {
    if(toSort[i+2]<toSort[i])
     {
      std::swap(toSort[i],toSort[i+2]);
     }
   }
  else
   {
    if(toSort[i+1]<toSort[i+2])
     {
      std::swap(toSort[i],toSort[i+1]);
     }
    else
     {
      std::swap(toSort[i],toSort[i+2]);
     }
   }
 if(toSort[i+2]<toSort[i+1])
  {
   std::swap(toSort[i+1],toSort[i+2]);
  }
 int minElem=i,minElem2=i+1,maxElem=i+2;
 while(minElem2>1 && toSort[minElem2]<toSort[minElem-1])
  {
   std::swap(toSort[minElem],toSort[minElem-1]);
   std::swap(toSort[minElem2],toSort[minElem2-1]);
   minElem--;
   minElem2--;
  }
 while(minElem>0 && toSort[minElem]<toSort[minElem-1])
  {
   std::swap(toSort[minElem],toSort[minElem-1]);
   minElem--;
  }
 while(maxElem<(toSort.size()-1) && toSort[maxElem]>toSort[maxElem+1])
  {
   std::swap(toSort[maxElem],toSort[maxElem+1]);
   maxElem++;
  }
 }
}
\end{lstlisting}








\subsection{Wyniki}
\par Rys.~\ref{fig:bubbleRand} przedstawia efekt porównania działania obu algorytmów dla tablic z losowymi elementami. Z przedstawionego wykresu wyraźnie widać przyspieszenie. Maksymalne przyspieszenie dla tego algorytmu wynosi $\approx 70\%$. Dzięki zastosowaniu wewnętrznych pętli \textit{while} które sterują zachowaniem bąbelków można bardzo szybko przyspieszyć algorytm. Dzięki temu że średnio każda pętla wykonuję się połowę rozmiaru tablicy. Wiec teoretyczne przyspieszenie powinno być co najmniej $50 \% $.	
\par Rys.~\ref{fig:bubbleBest} reprezentuje graficznie otrzymane wyniki z porównania algorytmu sortowania bąbelkowego dla par i normalnego dla posortowanej tablicy. Ponieważ widoczna na wykresie czerwona linia, reprezentująca sortowanie dla par, jest zawsze bliska zeru, mozna wyciągnać wniosek. Sortowanie to ma złożoność obliczeniową $O(n)$. Wiec przyspieszenie wynosi $\approx 99\%$
\par Rys.~\ref{fig:bubbleWorst} przedstawia wyniki dla tablicy posortowanej w druga stronę. Przyspieszenie algorytmu wynosi w tym wypadku $\approx 50\%$. Ponieważ używamy dwóch bąbelków, w porównaniu do użycia jednego , zmniejsza czas wykonania o $50\%$.


\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortBubbleTupleTest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortBubbleTupleTest.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortBubbleTupleTest.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy ze elementami losowymi}\label{fig:bubbleRand}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortBubbleTupleTestBest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortBubbleTupleTestBest.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortBubbleTupleTestBest.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najlepszym rozkładem elementów}\label{fig:bubbleBest}
  \end{center}
\end{figure}\FloatBarrier
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortBubbleTupleTestWorst.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortBubbleTupleTestWorst.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortBubbleTupleTestWorst.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najgorszym rozkładem elementów}\label{fig:bubbleWorst}
  \end{center}
\end{figure}
\FloatBarrier

\section{Algorytm sortowania przez wybieranie}
\subsection{Dla dwóch elementów}
Podstawowa wersja algorytmu zakłada wybieranie najmniejszej lub największej wartości z zbioru. Ten pomysł wybiera największą oraz najmniejszą wartość.
\begin{itemize}
\item Pobierz element który znajduję się na początku, $begin$, zbioru $V$.
\item Pobierz element który znajduję się na końcu, $end$, zbioru $V$.
\item Zakładając że pobieramy element najmniejszy $min$ oraz element największy $max$ ze zbioru $V$, zamień $min$ z $begin$ a $max$ z $end$.
\item Ustaw początek zbioru $begin$ na element z indeksem o jeden większy niż $begin$, a koniec na element z indeksem o jeden mniejszym niż $end$.
\end{itemize}
 
\subsubsection{Oszacowanie złożoności}
\paragraph{Optymistyczna}
Najlepszy przypadek tego algorytmu ma złożoność obliczeniową $O(n^2)$. 
\begin{itemize}
\item Pętla \textit{while}(11 linijka) wykonuje się zawsze $\frac{n}{2}$, ponieważ przy każdej iteracji usuwane są 2 elementy.
\item Pętla \textit{for}(14 linijka) wykonuje się zawsze $\frac{n}{2}$, ponieważ zawsze wykonuje się tyle samo razy co poprzednia.
\end{itemize}

\begin{equation*}
T \approx \frac{n}{2} \cdot \frac{n}{2} = \frac{n^2}{4}
\end{equation*}
\wyjT
\paragraph{Pesymistyczna}
Najgorszy przypadek algorytmu sortowania przez wybieranie dla par ma złożoność obliczeniową $O(n^2)$.
\begin{itemize}
\item Pętla \textit{while}(11 linijka) wykonuje się zawsze $\frac{n}{2}$, ponieważ przy każdej iteracji usuwane sa 2 elementy.
\item Pętla \textit{for}(14 linijka) wykonuje się zawsze $\frac{n}{2}$, ponieważ zawsze wykonuje sie tyle samo razy co poprzednia.
\end{itemize}
\begin{equation*}
T \approx \frac{n}{2} \cdot \frac{n}{2} = \frac{n^2}{4}
\end{equation*}
\wyjT
\paragraph{Średnia}
Dla losowych elementów w tablicy sortowanie to ma złożoność obliczeniową $O(n^2)$.
\begin{itemize}
\item Pętla \textit{while}(11 linijka) wykonuje się zawsze $\frac{n}{2}$, ponieważ przy każdej iteracji usuwane są 2 elementy.
\item Pętla \textit{for}(14 linijka) wykonuje się zawsze $\frac{n}{2}$, ponieważ zawsze wykonuje się tyle samo razy co poprzednia.
\end{itemize}

\begin{equation*}
T \approx \frac{n}{2} \cdot \frac{n}{2} = \frac{n^2}{4}
\end{equation*}
\wyjT


\subsubsection{Kod}
\begin{lstlisting}[caption={Sortowanie przez wybieranie dla par},label={lst:wybieranie}]
void sort(std::vector<int> &toSort)
{
 int vectorSize=0;
 if(toSort.size()%2!=0)
  {
   vectorSize++;
   std::iter_swap((std::min_element(toSort.begin(),toSort.end())),toSort.begin());
  }
 std::vector<int>::iterator _begin = toSort.begin()+vectorSize;
 std::vector<int>::iterator _end = toSort.end() - 1;
 while (_begin < _end)
  {
   std::vector<int>::iterator it=_begin,_min=it,_max=it;
   for (it = _begin; it <= _end; ++it)
    {
     if ((*it) < (*_min))
      {
       _min = it;
      }
     else if ((*it) > (*_max))
      {
       _max = it;
      }
    }
 std::iter_swap(_min,_begin);
 if(_begin==_max)
  {
   _max=_min;
  }
 std::iter_swap(_max,_end);
 ++_begin;
 --_end;
  }
}
\end{lstlisting}
\subsection{Dla trzech elementów}

\subsubsection{Oszacowanie złożoności}
\paragraph{Optymistyczna}

\paragraph{Pesymistyczna}

\paragraph{Średnia}



\subsubsection{Kod}
\begin{lstlisting}[caption={Sortowanie przez wybieranie dla par},label={lst:wybieranie}]
void sort(std::vector<int> &toSort)
{

}
\end{lstlisting}

\subsection{Wyniki}
Jak widać na powyższych założeniach teoretycznych każdy z przykładów ma taką samą złożoność obliczeniową. Wynika to z faktu że każda pętla musi być wykonana zawsze i wymaganą ilość razy.	
\par Rys.\ref{fig:wyb} przedstawia porównanie szybkości wykonywania się obliczeń dla tablicy z danymi losowymi. Przyspieszenie wynosi $\approx 40\%$. 
\par Rys.\ref{fig:wybBest} przedstawia najgorszy z trzech możliwych wynik gdzie przyspieszenie wynosi $\approx 21\%$. 
\par Rys.\ref{fig:wybWorst} reprezentuje dane pomiarowe na których widać ze przyspieszenie wynosi $\approx 41\%$. \\
Ponieważ każde z przypadków sortowań ma taką samą złożoność obliczeniową całe przyspieszenie jest zależne od znalezienia wartości maksymalnej i minimalnej. Ponieważ w algorytmie dla par przeszukujemy tablice wejściową i wybieramy od razu obydwie wartości, to teoretyczne przyspieszenie powinno wynieść $\approx 50\%$.
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortSelectionTupleTest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortSelectionTupleTest.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortSelectionTupleTest.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy ze elementami losowymi}\label{fig:wyb}
  \end{center}
  \end{figure}
  \begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortSelectionTupleTestBest.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortSelectionTupleTestBest.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortSelectionTupleTestBest.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najlepszym rozkładem elementów}\label{fig:wybBest}
  \end{center}
  \end{figure}
  \begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \begin{axis}
      
        \addplot[green,mark=x,legend entry=$Normalny$] 
        table[x=column 1,y=column 2,col sep=comma] {sortSelectionTupleTestWorst.csv}; 
    
        \addplot[red,mark=x,legend entry=$Dla\;par$] 
        table[x=column 1,y=column 3,col sep=comma] {sortSelectionTupleTestWorst.csv};
        \addplot[blue,mark=x,legend entry=$Dla\;trojek$] 
        table[x=column 1,y=column 4,col sep=comma] {sortSelectionTupleTestWorst.csv};
      \end{axis}
    \end{tikzpicture}
    \caption{Wykres dla tablicy z najgorszym rozkładem elementów}\label{fig:wybWorst}
  \end{center}
  \end{figure}
\FloatBarrier


\end{document}
